<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>leetcode每日一题 单词接龙 II 2020.6.7 | Alex的Blog</title><meta name="description" content="题目描述给定两个单词（beginWord 和 endWord）和一个字典 wordList，找出所有从 beginWord 到 endWord 的最短转换序列。转换需遵循如下规则：  每次转换只能改变一个字母。 转换过程中的中间单词必须是字典中的单词。  说明:  如果不存在这样的转换序列，返回一个空列表。 所有单词具有相同的长度。 所有单词只由小写字母组成。 字典中不存在重复的单词。 你可以假设"><meta name="keywords" content="算法,oj,Leetcode"><meta name="author" content="Alex"><meta name="copyright" content="Alex"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="leetcode每日一题 单词接龙 II 2020.6.7"><meta name="twitter:description" content="题目描述给定两个单词（beginWord 和 endWord）和一个字典 wordList，找出所有从 beginWord 到 endWord 的最短转换序列。转换需遵循如下规则：  每次转换只能改变一个字母。 转换过程中的中间单词必须是字典中的单词。  说明:  如果不存在这样的转换序列，返回一个空列表。 所有单词具有相同的长度。 所有单词只由小写字母组成。 字典中不存在重复的单词。 你可以假设"><meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><meta property="og:type" content="article"><meta property="og:title" content="leetcode每日一题 单词接龙 II 2020.6.7"><meta property="og:url" content="http://yoursite.com/2020/06/07/leetcode-q126/"><meta property="og:site_name" content="Alex的Blog"><meta property="og:description" content="题目描述给定两个单词（beginWord 和 endWord）和一个字典 wordList，找出所有从 beginWord 到 endWord 的最短转换序列。转换需遵循如下规则：  每次转换只能改变一个字母。 转换过程中的中间单词必须是字典中的单词。  说明:  如果不存在这样的转换序列，返回一个空列表。 所有单词具有相同的长度。 所有单词只由小写字母组成。 字典中不存在重复的单词。 你可以假设"><meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><meta property="article:published_time" content="2020-06-07T06:20:03.000Z"><meta property="article:modified_time" content="2020-06-07T06:58:36.886Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://yoursite.com/2020/06/07/leetcode-q126/"><link rel="prev" title="leetcode-q990" href="http://yoursite.com/2020/06/08/leetcode-q990/"><link rel="next" title="leetcode每日一题 除自身以外数组的乘积 2020.6.4" href="http://yoursite.com/2020/06/06/leetcode-q238/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.1"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/assets/imgs/profile.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">18</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">12</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">5</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目描述"><span class="toc-number">1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#解答"><span class="toc-number">2.</span> <span class="toc-text">解答</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#方法一"><span class="toc-number">2.1.</span> <span class="toc-text">方法一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法二"><span class="toc-number">2.2.</span> <span class="toc-text">方法二</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#时间改进"><span class="toc-number">2.3.</span> <span class="toc-text">时间改进</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Alex的Blog</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">leetcode每日一题 单词接龙 II 2020.6.7</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-06-07 14:20:03"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-06-07</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-06-07 14:58:36"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-06-07</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Leetcode/">Leetcode</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定两个单词（beginWord 和 endWord）和一个字典 wordList，找出所有从 beginWord 到 endWord 的最短转换序列。转换需遵循如下规则：</p>
<ol>
<li>每次转换只能改变一个字母。</li>
<li>转换过程中的中间单词必须是字典中的单词。</li>
</ol>
<p>说明:</p>
<ul>
<li>如果不存在这样的转换序列，返回一个空列表。</li>
<li>所有单词具有相同的长度。</li>
<li>所有单词只由小写字母组成。</li>
<li>字典中不存在重复的单词。</li>
<li>你可以假设 beginWord 和 endWord 是非空的，且二者不相同。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">beginWord &#x3D; &quot;hit&quot;,</span><br><span class="line">endWord &#x3D; &quot;cog&quot;,</span><br><span class="line">wordList &#x3D; [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [&quot;hit&quot;,&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;cog&quot;],</span><br><span class="line">  [&quot;hit&quot;,&quot;hot&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>这个题难度不大，大概相关知识点就是DFS，回溯，Dijkstra之类的，就是编码很麻烦</p>
<h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>自己的方法，首先两两比较，只差一个字母的记为1，表示连通。然后用类似dijkstra的方法，把前驱数组的每个元素改为了list，保存所有前驱节点，最后用递归做DFS，输出结果。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    dis = <span class="number">0</span></span><br><span class="line">    minD = []</span><br><span class="line">    queue = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">returnDistance</span><span class="params">(self, begin: str, end: str)</span> -&gt; int:</span></span><br><span class="line">        counter = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(begin)):</span><br><span class="line">            <span class="keyword">if</span> begin[i] != end[i]:</span><br><span class="line">                counter += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> counter == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 类似dijkstra，每个pre[i]是一个List，都能保存所有的前驱节点，然后用DFS做遍历。</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMinDistance</span><span class="params">(self, beginIndex: int, endIndex: int, matrix: List[List[int]])</span>:</span></span><br><span class="line">        checked = [beginIndex]</span><br><span class="line">        finish = <span class="literal">False</span></span><br><span class="line">        pre = [[] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(matrix))]</span><br><span class="line">        pre[beginIndex].append(beginIndex)</span><br><span class="line">        <span class="keyword">while</span> (endIndex <span class="keyword">not</span> <span class="keyword">in</span> checked) <span class="keyword">and</span> <span class="keyword">not</span> (finish):</span><br><span class="line">            checkedBuffer = []  <span class="comment"># 没这个会死循环</span></span><br><span class="line">            finish = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> checked:</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(len(matrix)):  <span class="comment"># 检查所有的节点</span></span><br><span class="line">                    <span class="keyword">if</span> (j <span class="keyword">not</span> <span class="keyword">in</span> checked) <span class="keyword">and</span> (matrix[i][j] == <span class="number">1</span>):  <span class="comment"># 如果可以到达</span></span><br><span class="line">                        checkedBuffer.append(j)</span><br><span class="line">                        pre[j].append(i)</span><br><span class="line">                        finish = <span class="literal">False</span></span><br><span class="line">            checked = checked + list(set(checkedBuffer))</span><br><span class="line">        <span class="keyword">return</span> pre</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">DFS</span><span class="params">(self, beginIndex: int, endIndex: int, matrix: List[List[int]])</span>:</span></span><br><span class="line">        self.queue.insert(<span class="number">0</span>, endIndex)</span><br><span class="line">        <span class="keyword">if</span> beginIndex == endIndex:</span><br><span class="line">            q_t = list(self.queue)</span><br><span class="line">            self.minD.append(q_t)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> matrix[endIndex]:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> self.queue:</span><br><span class="line">                self.DFS(beginIndex, i, matrix)</span><br><span class="line">                self.queue.remove(i)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLadders</span><span class="params">(self, beginWord: str, endWord: str, wordList: List[str])</span> -&gt; List[List[str]]:</span></span><br><span class="line">        self.dis = <span class="number">0</span></span><br><span class="line">        self.minD = []</span><br><span class="line">        self.queue = []</span><br><span class="line">        <span class="keyword">if</span> endWord <span class="keyword">not</span> <span class="keyword">in</span> wordList:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">if</span> beginWord <span class="keyword">not</span> <span class="keyword">in</span> wordList:</span><br><span class="line">            wordList.append(beginWord)</span><br><span class="line">        arr = [[self.returnDistance(i, j) <span class="keyword">for</span> i <span class="keyword">in</span> wordList] <span class="keyword">for</span> j <span class="keyword">in</span> wordList]</span><br><span class="line">        pre = self.getMinDistance(wordList.index(beginWord), wordList.index(endWord), arr)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> len(pre[wordList.index(endWord)]) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># DFS打印</span></span><br><span class="line">            self.DFS(wordList.index(beginWord), wordList.index(endWord), pre)</span><br><span class="line">            self.minD = [[wordList[j] <span class="keyword">for</span> j <span class="keyword">in</span> self.minD[i]] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(self.minD))]</span><br><span class="line">            <span class="keyword">return</span> self.minD</span><br></pre></td></tr></table></figure>

<p>最后悲惨的超时了。</p>
<h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>方法二类似上面的，构造距离图都一样，之后开始不同。构造一个路径队列queue，每个元素都是一个数组，储存路径，再构造一个cost数组储存从起点到i的最短路径的值。然后做while循环，条件是queue不为空，每次取出一个值(now=queue.poll())，判断now的最后一位是不是结束，是的话就输出一个，不是的话进入循环，判断所有与这个点相邻的点是不是可以通过这个点缩短起点到相邻点之间的距离（dijkstra思想），这里利用cost数组。如果能缩短就压入queue。</p>
<p>class Solution {<br>    private static final int INF = 1 &lt;&lt; 20;<br>    private Map&lt;String, Integer&gt; wordId; // 单词到id的映射<br>    private ArrayList<String> idWord; // id到单词的映射<br>    private ArrayList<Integer>[] edges; // 图的边</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    wordId = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    idWord = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; findLadders(String beginWord, String endWord, List&lt;String&gt; wordList) &#123;</span><br><span class="line">    <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 将wordList所有单词加入wordId中 相同的只保留一个 // 并为每一个单词分配一个id</span></span><br><span class="line">    <span class="keyword">for</span> (String word : wordList) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!wordId.containsKey(word)) &#123; </span><br><span class="line">            wordId.put(word, id++);</span><br><span class="line">            idWord.add(word);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若endWord不在wordList中 则无解</span></span><br><span class="line">    <span class="keyword">if</span> (!wordId.containsKey(endWord)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把beginWord也加入wordId中</span></span><br><span class="line">    <span class="keyword">if</span> (!wordId.containsKey(beginWord)) &#123;</span><br><span class="line">        wordId.put(beginWord, id++);</span><br><span class="line">        idWord.add(beginWord);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化存边用的数组</span></span><br><span class="line">    edges = <span class="keyword">new</span> ArrayList[idWord.size()];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; idWord.size(); i++) &#123;</span><br><span class="line">        edges[i] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加边</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; idWord.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; idWord.size(); j++) &#123;</span><br><span class="line">            <span class="comment">// 若两者可以通过转换得到 则在它们间建一条无向边</span></span><br><span class="line">            <span class="keyword">if</span> (transformCheck(idWord.get(i), idWord.get(j))) &#123;</span><br><span class="line">                edges[i].add(j);</span><br><span class="line">                edges[j].add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> dest = wordId.get(endWord); <span class="comment">// 目的ID</span></span><br><span class="line">    List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">// 存答案</span></span><br><span class="line">    <span class="keyword">int</span>[] cost = <span class="keyword">new</span> <span class="keyword">int</span>[id]; <span class="comment">// 到每个点的代价</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; id; i++) &#123;</span><br><span class="line">        cost[i] = INF; <span class="comment">// 每个点的代价初始化为无穷大</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将起点加入队列 并将其cost设为0</span></span><br><span class="line">    Queue&lt;ArrayList&lt;Integer&gt;&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    ArrayList&lt;Integer&gt; tmpBegin = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    tmpBegin.add(wordId.get(beginWord));</span><br><span class="line">    q.add(tmpBegin);</span><br><span class="line">    cost[wordId.get(beginWord)] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始广度优先搜索</span></span><br><span class="line">    <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; now = q.poll();</span><br><span class="line">        <span class="keyword">int</span> last = now.get(now.size() - <span class="number">1</span>); <span class="comment">// 最近访问的点</span></span><br><span class="line">        <span class="keyword">if</span> (last == dest) &#123; <span class="comment">// 若该点为终点则将其存入答案res中</span></span><br><span class="line">            ArrayList&lt;String&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> index : now) &#123;</span><br><span class="line">                tmp.add(idWord.get(index)); <span class="comment">// 转换为对应的word</span></span><br><span class="line">            &#125;</span><br><span class="line">            res.add(tmp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 该点不为终点 继续搜索</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges[last].size(); i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> to = edges[last].get(i);</span><br><span class="line">                <span class="comment">// 此处&lt;=目的在于把代价相同的不同路径全部保留下来</span></span><br><span class="line">                <span class="keyword">if</span> (cost[last] + <span class="number">1</span> &lt;= cost[to]) &#123;</span><br><span class="line">                    cost[to] = cost[last] + <span class="number">1</span>;</span><br><span class="line">                    <span class="comment">// 把to加入路径中</span></span><br><span class="line">                    ArrayList&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;(now); tmp.add(to);</span><br><span class="line">                    q.add(tmp); <span class="comment">// 把这个路径加入队列</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个字符串是否可以通过改变一个字母后相等</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">transformCheck</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> differences = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str1.length() &amp;&amp; differences &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str1.charAt(i) != str2.charAt(i)) &#123;</span><br><span class="line">            ++differences;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> differences == <span class="number">1</span>;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间改进"><a href="#时间改进" class="headerlink" title="时间改进"></a>时间改进</h3><p>方法一会超时，改进的话就是把构建图和BFS放到一个循环里，节约时间。同时在计算两个单词的距离的时候，用穷举法穷举出所有的改进单词，然后用hashmap（set）直接判断在不在，很快。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLadders</span><span class="params">(self, beginWord: str, endWord: str, wordList: List[str])</span> -&gt; List[List[str]]:</span></span><br><span class="line">        <span class="comment"># 先将 wordList 放到哈希表里，便于判断某个单词是否在 wordList 里</span></span><br><span class="line">        word_set = set(wordList)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> len(word_set) == <span class="number">0</span> <span class="keyword">or</span> endWord <span class="keyword">not</span> <span class="keyword">in</span> word_set:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        successors = defaultdict(set)</span><br><span class="line">        <span class="comment"># 第 1 步：使用广度优先遍历得到后继结点列表 successors</span></span><br><span class="line">        <span class="comment"># key：字符串，value：广度优先遍历过程中 key 的后继结点列表</span></span><br><span class="line">        found = self.__bfs(beginWord, endWord, word_set, successors)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> found:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="comment"># 第 2 步：基于后继结点列表 successors ，使用回溯算法得到所有最短路径列表</span></span><br><span class="line">        path = [beginWord]</span><br><span class="line">        self.__dfs(beginWord, endWord, successors, path, res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__bfs</span><span class="params">(self, beginWord, endWord, word_set, successors)</span>:</span></span><br><span class="line">        queue = deque()</span><br><span class="line">        queue.append(beginWord)</span><br><span class="line"></span><br><span class="line">        visited = set()</span><br><span class="line">        visited.add(beginWord)</span><br><span class="line"></span><br><span class="line">        found = <span class="literal">False</span></span><br><span class="line">        word_len = len(beginWord)</span><br><span class="line">        next_level_visited = set()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            current_size = len(queue)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(current_size):</span><br><span class="line">                current_word = queue.popleft()</span><br><span class="line">                word_list = list(current_word)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(word_len):</span><br><span class="line">                    origin_char = word_list[j]</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> k <span class="keyword">in</span> string.ascii_lowercase:</span><br><span class="line">                        word_list[j] = k</span><br><span class="line">                        next_word = <span class="string">''</span>.join(word_list)</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> next_word <span class="keyword">in</span> word_set:</span><br><span class="line">                            <span class="keyword">if</span> next_word <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                                <span class="keyword">if</span> next_word == endWord:</span><br><span class="line">                                    found = <span class="literal">True</span></span><br><span class="line">                                next_level_visited.add(next_word)</span><br><span class="line">                                queue.append(next_word)</span><br><span class="line"></span><br><span class="line">                                successors[current_word].add(next_word)</span><br><span class="line">                    word_list[j] = origin_char</span><br><span class="line">            <span class="keyword">if</span> found:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="comment"># 取两集合全部的元素（并集，等价于将 next_level_visited 里的所有元素添加到 visited 里）</span></span><br><span class="line">            visited |= next_level_visited</span><br><span class="line">            next_level_visited.clear()</span><br><span class="line">        <span class="keyword">return</span> found</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__dfs</span><span class="params">(self, beginWord, endWord, successors, path, res)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> beginWord == endWord:</span><br><span class="line">            res.append(path[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> beginWord <span class="keyword">not</span> <span class="keyword">in</span> successors:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        successor_words = successors[beginWord]</span><br><span class="line">        <span class="keyword">for</span> next_word <span class="keyword">in</span> successor_words:</span><br><span class="line">            path.append(next_word)</span><br><span class="line">            self.__dfs(next_word, endWord, successors, path, res)</span><br><span class="line">            path.pop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    beginWord = <span class="string">"hit"</span></span><br><span class="line">    endWord = <span class="string">"cog"</span></span><br><span class="line">    wordList = [<span class="string">"hot"</span>, <span class="string">"dot"</span>, <span class="string">"dog"</span>, <span class="string">"lot"</span>, <span class="string">"log"</span>, <span class="string">"cog"</span>]</span><br><span class="line"></span><br><span class="line">    solution = Solution()</span><br><span class="line">    res = solution.findLadders(beginWord, endWord, wordList)</span><br><span class="line">    print(res)</span><br></pre></td></tr></table></figure>

<p>进一步改进可以用双向的BFS，主要是维护两个visited列表，从元素少的那一边开始，反正就是能快一点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayDeque;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; findLadders(String beginWord, String endWord, List&lt;String&gt; wordList) &#123;</span><br><span class="line">        <span class="comment">// 先将 wordList 放到哈希表里，便于判断某个单词是否在 wordList 里</span></span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Set&lt;String&gt; wordSet = <span class="keyword">new</span> HashSet&lt;&gt;(wordList);</span><br><span class="line">        <span class="keyword">if</span> (wordSet.size() == <span class="number">0</span> || !wordSet.contains(endWord)) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第 1 步：使用双向广度优先遍历得到后继结点列表 successors</span></span><br><span class="line">        <span class="comment">// key：字符串，value：广度优先遍历过程中 key 的后继结点列表</span></span><br><span class="line">        Map&lt;String, Set&lt;String&gt;&gt; successors = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">boolean</span> found = bidirectionalBfs(beginWord, endWord, wordSet, successors);</span><br><span class="line">        <span class="keyword">if</span> (!found) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第 2 步：基于后继结点列表 successors ，使用回溯算法得到所有最短路径列表</span></span><br><span class="line">        Deque&lt;String&gt; path = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        path.addLast(beginWord);</span><br><span class="line">        dfs(beginWord, endWord, successors, path, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">bidirectionalBfs</span><span class="params">(String beginWord,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     String endWord,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     Set&lt;String&gt; wordSet,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     Map&lt;String, Set&lt;String&gt;&gt; successors)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 记录访问过的单词</span></span><br><span class="line">        Set&lt;String&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        visited.add(beginWord);</span><br><span class="line">        visited.add(endWord);</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; beginVisited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        beginVisited.add(beginWord);</span><br><span class="line">        Set&lt;String&gt; endVisited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        endVisited.add(endWord);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> wordLen = beginWord.length();</span><br><span class="line">        <span class="keyword">boolean</span> forward = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">boolean</span> found = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 在保证了 beginVisited 总是较小（可以等于）大小的集合前提下，&amp;&amp; !endVisited.isEmpty() 可以省略</span></span><br><span class="line">        <span class="keyword">while</span> (!beginVisited.isEmpty() &amp;&amp; !endVisited.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 一直保证 beginVisited 是相对较小的集合，方便后续编码</span></span><br><span class="line">            <span class="keyword">if</span> (beginVisited.size() &gt; endVisited.size()) &#123;</span><br><span class="line">                Set&lt;String&gt; temp = beginVisited;</span><br><span class="line">                beginVisited = endVisited;</span><br><span class="line">                endVisited = temp;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 只要交换，就更改方向，以便维护 successors 的定义</span></span><br><span class="line">                forward = !forward;</span><br><span class="line">            &#125;</span><br><span class="line">            Set&lt;String&gt; nextLevelVisited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">            <span class="comment">// 默认 beginVisited 是小集合，因此从 beginVisited 出发</span></span><br><span class="line">            <span class="keyword">for</span> (String currentWord : beginVisited) &#123;</span><br><span class="line">                <span class="keyword">char</span>[] charArray = currentWord.toCharArray();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; wordLen; i++) &#123;</span><br><span class="line">                    <span class="keyword">char</span> originChar = charArray[i];</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">char</span> j = <span class="string">'a'</span>; j &lt;= <span class="string">'z'</span>; j++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (charArray[i] == j) &#123;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        charArray[i] = j;</span><br><span class="line">                        String nextWord = <span class="keyword">new</span> String(charArray);</span><br><span class="line">                        <span class="keyword">if</span> (wordSet.contains(nextWord)) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (endVisited.contains(nextWord)) &#123;</span><br><span class="line">                                found = <span class="keyword">true</span>;</span><br><span class="line">                                <span class="comment">// 在另一侧找到单词以后，还需把这一层关系添加到「后继结点列表」</span></span><br><span class="line">                                addToSuccessors(successors, forward, currentWord, nextWord);</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (!visited.contains(nextWord)) &#123;</span><br><span class="line">                                nextLevelVisited.add(nextWord);</span><br><span class="line">                                addToSuccessors(successors, forward, currentWord, nextWord);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    charArray[i] = originChar;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            beginVisited = nextLevelVisited;</span><br><span class="line">            visited.addAll(nextLevelVisited);</span><br><span class="line">            <span class="keyword">if</span> (found) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> found;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(String beginWord,</span></span></span><br><span class="line"><span class="function"><span class="params">                     String endWord,</span></span></span><br><span class="line"><span class="function"><span class="params">                     Map&lt;String, Set&lt;String&gt;&gt; successors,</span></span></span><br><span class="line"><span class="function"><span class="params">                     Deque&lt;String&gt; path,</span></span></span><br><span class="line"><span class="function"><span class="params">                     List&lt;List&lt;String&gt;&gt; res)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (beginWord.equals(endWord)) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!successors.containsKey(beginWord)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; successorWords = successors.get(beginWord);</span><br><span class="line">        <span class="keyword">for</span> (String successor : successorWords) &#123;</span><br><span class="line">            path.addLast(successor);</span><br><span class="line">            dfs(successor, endWord, successors, path, res);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addToSuccessors</span><span class="params">(Map&lt;String, Set&lt;String&gt;&gt; successors, <span class="keyword">boolean</span> forward,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 String currentWord, String nextWord)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!forward) &#123;</span><br><span class="line">            String temp = currentWord;</span><br><span class="line">            currentWord = nextWord;</span><br><span class="line">            nextWord = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Java 1.8 以后支持</span></span><br><span class="line">        successors.computeIfAbsent(currentWord, a -&gt; <span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">        successors.get(currentWord).add(nextWord);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; wordList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        wordList.add(<span class="string">"hot"</span>);</span><br><span class="line">        wordList.add(<span class="string">"dot"</span>);</span><br><span class="line">        wordList.add(<span class="string">"dog"</span>);</span><br><span class="line">        wordList.add(<span class="string">"lot"</span>);</span><br><span class="line">        wordList.add(<span class="string">"log"</span>);</span><br><span class="line">        wordList.add(<span class="string">"cog"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        String beginWord = <span class="string">"hit"</span>;</span><br><span class="line">        String endWord = <span class="string">"cog"</span>;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res = solution.findLadders(beginWord, endWord, wordList);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Alex</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/06/07/leetcode-q126/">http://yoursite.com/2020/06/07/leetcode-q126/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com" target="_blank">Alex的Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a><a class="post-meta__tags" href="/tags/oj/">oj</a><a class="post-meta__tags" href="/tags/Leetcode/">Leetcode</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="/assets/imgs/wechat.jpg" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="post-qr-code__img" src="/assets/imgs/alipay.jpg" alt="支付宝"/><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/06/08/leetcode-q990/"><img class="prev_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">leetcode-q990</div></div></a></div><div class="next-post pull_right"><a href="/2020/06/06/leetcode-q238/"><img class="next_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">leetcode每日一题 除自身以外数组的乘积 2020.6.4</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/06/06/leetcode-q128/" title="leetcode每日一题 最长连续序列 2020.6.6"><img class="relatedPosts_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-06-06</div><div class="relatedPosts_title">leetcode每日一题 最长连续序列 2020.6.6</div></div></a></div><div class="relatedPosts_item"><a href="/2020/06/06/leetcode-q238/" title="leetcode每日一题 除自身以外数组的乘积 2020.6.4"><img class="relatedPosts_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-06-06</div><div class="relatedPosts_title">leetcode每日一题 除自身以外数组的乘积 2020.6.4</div></div></a></div><div class="relatedPosts_item"><a href="/2017/12/03/e3-80-8e-e6-95-b0-e6-8d-ae-e7-bb-93-e6-9e-84-e5-ae-9e-e9-aa-8c-e3-80-8f-e5-9b-be-e7-9a-84-e6-9c-80-e7-9f-ad-e8-b7-af-e5-be-84-ef-bc-88dijkstra-e7-ae-97-e6-b3-95-ef-bc-89/" title="『数据结构实验』图的最短路径（Dijkstra算法）"><img class="relatedPosts_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2017-12-03</div><div class="relatedPosts_title">『数据结构实验』图的最短路径（Dijkstra算法）</div></div></a></div></div><div class="clear_both"></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2017 - 2020 By Alex</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text">欢迎━(*｀∀´*)ノ亻!</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@3/instantpage.min.js" type="module"></script></body></html>